---
layout:     post
title:      HPCC SIGCOMM 2019
subtitle:   HPCC High Precision Congestion Control
date:       2020-4-27
author:     Yiran
header-img: img/post-bg-lake.jpg
catalog: true
tags:
    - Congestion Control
    - Transport in Datacenter
---






### Motivation



<img width="450" height="350" src="/img/post-hpcc-1.png"/>




### Design

  针对三个问题，PCN有三个核心设计点：
- 准确识别congestion root flow （就是真正造成拥塞的流，与congestion victim flow 相对应）

  已有的拥塞控制算法，只根据队列长度来识别congestion root （Timely根据RTT，本质上也是队长），当网络中PFC没有被触发时，根据队长是准的，但是如果PFC被触发，端口队长累积既可能是因为这个端口就是拥塞发生的端口，也可能因为这个端口经历了拥塞扩展，被pause住导致到达的数据包累积。因此，PCN中对端口状态进行了划分，分成了三种，非拥塞、准拥塞以及真拥塞。重点是对准拥塞端口的理解。准拥塞的端口处于一个在不断收到PAUSE和RESUME针的阶段，端口的输出速率小于线速，输入速率取决于流量。
  <img width="250" height="250" src="/img/post-pcn-1.png"/>

  交换机标记核心思想：```被PAUSE住的数据包不标```
  <img width="350" height="350" src="/img/post-pcn-2.png"/>

  仅通过交换机标记是不够的，因为在连续的PAUSE RESUME之间的数据包仍可能会被标记。因此PCN将真正的拥塞识别放到接收端去做：

  如果是真拥塞端口，真拥塞流的数据包一定会连续的被标记；准拥塞端口的数据包一定不被连续标记，根据这一特征，由接收端区分谁是真正的拥塞流
  
- receiver-driven的减速，使congestion root flow直接减速到合适的速率

  这里文章指出了，针对无损以太网，造成拥塞的流的正确速率就是它在接收方的接收速率。这一点需要好好理解。可以说，采用拥塞流的接收速率来指导减速是彻底的解决方法。最简单的例子就是多对一的incast场景。实际上复杂的场景下这个思想也是正确的。对任意一条拥塞流，它的接收速率就是能通过瓶颈的最大速率。
  

- 先缓慢后激进的增速策略

  文章作者启发式设计了一个先缓慢后激进的增长函数

### Thoughts

PCN这篇论文笔者认为是非常solid的工作，对拥塞控制架构的核心模块进行了彻底的改进，文章读起来让人觉得能学到很多内容。PCN的拥塞识别可以做到接近100%准确，对拥塞流的减速也可以在一个RTT内直接减到最合适的速率。从性能上笔者认为PCN已经将无损以太网的拥塞控制协议做的非常好了。

当然PCN最不足的问题是对交换机和接收端都进行了改动，特别是拥塞识别实际上需要交换机与接收端同时配合，拥塞流减速也完全需要接收端的配合，对部署要求高。




### 参考文献

[HPCC: High Precision Congestion Control](https://liyuliang001.github.io/publications/hpcc.pdf)





